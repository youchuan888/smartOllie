<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" /  <meta property="og:title" content="a smart Top to down lighting with controllable 5 direction beam"/>
  <meta property="og:description" content="This smart color system show rich function those include solid color, RGB mix color, multi-CCT warm white, color drift, breathing, fire-fly like and slide dimmer etc."/>
  <meta property="og:image" content="lighting.jpg"/>

  <title>Smart Ollie</title>
  <style>
    body {
      font-family: sans-serif;
      text-align: center;
      max-width: 320px;
      margin: auto;
    }
    .title {
      font-size: 1.8em;
      margin: 1em 0;
    }
    .color-grid, .function-buttons {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 0.1em;
      margin-bottom: 0.5em;
    }
    .warm-grid{
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 0.1em;
      margin-bottom: 0.1em;
    }
    canvas {
      width: 200px;
      height: 200px;
      border-radius: 50%;
      margin-bottom: 0.1em;
      touch-action: none;
    }
    .button, .connect-btn {
      padding: 1em;
      margin: 0.1em;
      font-size: 1em;
      border: none;
      border-radius: 0.5em;
      cursor: pointer;
    }
    .connect-btn {
      background-color: #444;
      color: white;
    }
    .status, .log {
      background: #eee;
      padding: 0.8em;
      margin-top: 0.1em;
      font-size: 0.9em;
    }
    input[type=range] {
      width: 100%;
      height: 50px;
    }
  </style>
</head>
<body>
  <div class="title"  style="font-weight: bold;">Smart Color Lighting</div>

  <div class="color-grid" id="colorButtons">
    <button class="button" style="background:rgb(255,180,19)" onclick="sendData([4,0x52,255,89,19])"></button>
    <button class="button" style="background:rgb(255,154,112)" onclick="sendData([4,0x52,253,54,12])"></button>
    <button class="button" style="background:rgb(255,25,14)" onclick="sendData([4,0x52,255,25,14])"></button>
    <button class="button" style="background:rgb(250,120,120)" onclick="sendData([4,0x52,250,8,12])"></button>
    <button class="button" style="background:rgb(255,20,180)" onclick="sendData([4,0x52,255,16,48])"></button>
    <button class="button" style="background:rgb(255,10,200)" onclick="sendData([4,0x52,255,22,190])"></button>
    <button class="button" style="background:rgb(255,25,255)" onclick="sendData([4,0x52,255,53,185])"></button>
    <button class="button" style="background:rgb(200,70,230)" onclick="sendData([4,0x52,146,50,250])"></button>
    <button class="button" style="background:rgb(100,100,255)" onclick="sendData([4,0x52,48,16,255])"></button>
    <button class="button" style="background:rgb(17,188,246)" onclick="sendData([4,0x52,19,91,255])"></button>
    <button class="button" style="background:rgb(2,255,255)" onclick="sendData([4,0x52,17,188,246])"></button>
    <button class="button" style="background:rgb(0,255,80)" onclick="sendData([4,0x52,2,255,112])"></button>
    <button class="button" style="background:rgb(10,255,15)" onclick="sendData([4,0x52,0,255,80])"></button>
    <button class="button" style="background:rgb(255,240,15)" onclick="sendData([4,0x52,255,180,5])"></button>

  </div>

  <!-- Canvas Color Picker -->
  <canvas id="colorCircle" width="200" height="200"></canvas>

  <div class="warm-grid">
    <button class="button" style="background:#f5deb3" onclick="sendData([2,0x51,0x01])">3000K</button>
    <button class="button" style="background:#f4c27a" onclick="sendData([2,0x51,0x02])">2800K</button>
    <!--< button class="button" style="background:#ff0000" onclick="sendData([1,0x53])">ColorDrift/Pause</button>-->
    <button class="button" style="background:#ff0000" 
	onclick="
    	const state = this.getAttribute('data-state');
	sendData([1,0x53]);
    	if(state === 'off') {
        	this.textContent = 'ColorDrift';
        	this.setAttribute('data-state', 'on');
    	} else {
        	this.textContent = 'DriftPause';
        	this.setAttribute('data-state', 'off');
    	}" 
	data-state="off">ColorDrift</button>
  </div>

  <input type="range" min="0" max="3" value="2" id="slider" oninput="sliderChanged(this.value)">

  <div class="warm-grid">
    <button class="button" style="background:#999999" onclick="sendData([1,0x55])">Item</button>
    <button class="button" style="background:#aaaaaa" onclick="sendData([1,0x56])">Function</button>
    <button class="button" style="background:#cccccc" onclick="sendData([1,0x57])">Dimmer</button>
  </div>

  <hr style="border: 2px solid #ffffff;"> 

  <button class="connect-btn" style="background:#999999"onclick="connect()">Connect to Ollie</button>
  <button class="connect-btn" style="background:#999999" onclick="disconnect()">Disconnect Ollie</button>

  <div class="status" id="status">disconnected</div>
  <div class="log" id="log">Log will appear here.</div>

  <script>
    let bleDevice, bleServer, ledChar;
    let connected = false;
        class ECB02Controller {
            constructor() {
                this.device = null;
                this.server = null;
                this.service = null;
                this.txCharacteristic = null;
                this.rxCharacteristic = null;
                this.isConnected = false;
                
                // 正確的 UUID 格式
                this.serviceUUID = '0000fff0-0000-1000-8000-00805f9b34fb';
                this.txCharUUID = '0000fff1-0000-1000-8000-00805f9b34fb';
                this.rxCharUUID = '0000fff2-0000-1000-8000-00805f9b34fb';
            }
            async connect() {
                try {
                    updateStatus('正在搜索 BLE 設備...');
                    
                    // 方法1：接受所有設備，讓用戶選擇
                    this.device = await navigator.bluetooth.requestDevice({
                        acceptAllDevices: true,
                        optionalServices: [this.serviceUUID]
                    });

                    updateStatus('設備選擇完成，連接中...');
                    
                    // 檢查設備名稱
                    console.log('選擇的設備名稱:', this.device.name);
                    console.log('設備ID:', this.device.id);

                    this.server = await this.device.gatt.connect();
                    
                    // 獲取服務
                    this.service = await this.server.getPrimaryService(this.serviceUUID);
                    
                    // 獲取特徵
                    this.txCharacteristic = await this.service.getCharacteristic(this.txCharUUID);
                    this.rxCharacteristic = await this.service.getCharacteristic(this.rxCharUUID);
                    
                    // 啟用通知
                    await this.enableNotifications();
                    
                    this.isConnected = true;
                    updateStatus('連接成功！設備: ' + (this.device.name || '未知'));
                    
                    // 監聽斷開事件
                    this.device.addEventListener('gattserverdisconnected', () => {
                        this.handleDisconnect();
                    });
                    
                } catch (error) {
                    updateStatus('連接失敗: ' + error);
                    console.error('連接錯誤:', error);
                }
            }

            async enableNotifications() {
                try {
                    await this.txCharacteristic.startNotifications();
                    this.txCharacteristic.addEventListener('characteristicvaluechanged', 
                        this.handleNotification.bind(this));
                    console.log('通知已啟用');
                } catch (error) {
                    console.error('啟用通知失敗:', error);
                }
            }

            handleNotification(event) {
                const value = event.target.value;
                const text = new TextDecoder().decode(value);
                console.log('收到數據:', text);
                updateReceivedData(text);
            }

            async sendData(dataArray) {
                if (!this.isConnected || !this.rxCharacteristic) {
                    updateStatus('錯誤: 未連接');
                    return false;
                }

                try {
//                    const encoder = new TextEncoder();
//                    const value = encoder.encode(data);
                    let value = new Uint8Array(4);
		    if(dataArray[0]==1) value[0]=dataArray[1];
		    else if(dataArray[0]==2){
		    	value[0]=dataArray[1];
		    	value[1]=dataArray[2];
		    }else if(dataArray[0]==4){
		    	value[0]=dataArray[1];
		    	value[1]=dataArray[2];
		    	value[2]=dataArray[3];
		    	value[3]=dataArray[4];
		    }
                    await this.rxCharacteristic.writeValueWithoutResponse(value);
//		    await this.rxCharacteristic.writeValue(data);
                    console.log('發送成功:', dataArray);
		    log("Send OK="+ dataArray);
                    return true;
                    
                } catch (error) {
                    updateStatus('發送失敗: ' + error);
                    console.error('發送錯誤:', error);
                    return false;
                }
            }

            handleDisconnect() {
                this.isConnected = false;
                updateStatus('設備已斷開連接');
            }

            async disconnect() {
                if (this.device && this.device.gatt.connected) {
                    this.device.gatt.disconnect();
                }
                this.handleDisconnect();
            }
        }

        // 創建全局實例
        const ecb02 = new ECB02Controller();

        // UI 更新函數
        function updateStatus(message) {
            document.getElementById('status').textContent = '狀態: ' + message;
        }

        function updateReceivedData(data) {
            const display = document.getElementById('receivedData');
            display.textContent = '接收到的數據: ' + data;
        }

        // 按鈕事件處理
        async function connect() {
            await ecb02.connect();
        }

        async function disconnect() {
            await ecb02.disconnect();
        }

	async function sendColor(rgb) {
    		const data =new Uint8Array(5);
      		data[0]=4;
      		data[1]=0x52;
      		data[2]= rgb[0];
      		data[3]= rgb[1];
      		data[4]= rgb[2];
      		const success=await ecb02.sendData(data);
      		if(success) {
            		console.log('指令發送成功:', data);
      		}
    	}

        async function sendData(data) {
            const success = await ecb02.sendData(data);
            if (success) {
                console.log('指令發送成功:', data);
            }
	}

   async function sliderChanged(val) {
      const v = parseInt(val,10);
      const data = new Uint8Array(4);
      data[0]=2;
      data[1]=0x50;
      data[2] = v;
      const success1 = await ecb02.sendData(data);
//      const success1=sendData(data);
      if(success1) {
            console.log('指令發送成功:', data);
      }
//      log(`Slider Value ${v} => [${data.join(',')}]`);
    }

    function log(msg) {
      document.getElementById('log').textContent = msg;
    }

    // Draw HSV circle on canvas
    const canvas = document.getElementById('colorCircle');
    const ctx = canvas.getContext('2d');
    const radius = canvas.width / 2;
    const image = ctx.createImageData(canvas.width, canvas.height);
    for (let y = 0; y < canvas.height; y++) {
      for (let x = 0; x < canvas.width; x++) {
        const dx = x - radius;
        const dy = y - radius;
        const dist = Math.sqrt(dx * dx + dy * dy);
        const angle = Math.atan2(dy, dx);
        const hue = ((angle * 180 / Math.PI) + 360) % 360;
        const sat = Math.min(dist / radius, 1);
        const val = 1;
        const [r, g, b] = hsvToRgb(hue, sat, val);
        const idx = (y * canvas.width + x) * 4;
        image.data[idx] = r;
        image.data[idx + 1] = g;
        image.data[idx + 2] = b;
        image.data[idx + 3] = dist <= radius ? 255 : 0;
      }
    }
    ctx.putImageData(image, 0, 0);

    canvas.addEventListener('click', e => {
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      const pixel = ctx.getImageData(x, y, 1, 1).data;
      sendColor([pixel[0], pixel[1], pixel[2]]);
    });

    function hsvToRgb(h, s, v) {
      let c = v * s;
      let x = c * (1 - Math.abs((h / 60) % 2 - 1));
      let m = v - c;
      let [r, g, b] = [0, 0, 0];
      if (h < 60) [r, g, b] = [c, x, 0];
      else if (h < 120) [r, g, b] = [x, c, 0];
      else if (h < 180) [r, g, b] = [0, c, x];
      else if (h < 240) [r, g, b] = [0, x, c];
      else if (h < 300) [r, g, b] = [x, 0, c];
      else [r, g, b] = [c, 0, x];
      return [Math.round((r + m) * 255), Math.round((g + m) * 255), Math.round((b + m) * 255)];
    }
  </script>
</body>

</html>
